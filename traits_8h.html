<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Container Collection (CCC): ccc/traits.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Container Collection (CCC)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('traits_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">traits.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The C Container Collection Traits Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;private/private_traits.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for traits.h:</div>
<div class="dyncontent">
<div class="center"><img src="traits_8h__incl.png" border="0" usemap="#accc_2traits_8h" alt=""/></div>
<map name="accc_2traits_8h" id="accc_2traits_8h">
<area shape="rect" title="The C Container Collection Traits Interface." alt="" coords="1287,5,1381,31"/>
<area shape="rect" href="private__traits_8h_source.html" title=" " alt="" coords="1249,79,1419,104"/>
<area shape="rect" href="adaptive__map_8h.html" title="The Adaptive Map Interface." alt="" coords="157,328,295,353"/>
<area shape="rect" href="types_8h.html" title="The C Container Collection Fundamental Types." alt="" coords="1251,489,1334,515"/>
<area shape="rect" href="array__adaptive__map_8h.html" title="The Array Adaptive Map Interface." alt="" coords="591,328,771,353"/>
<area shape="rect" href="array__tree__map_8h.html" title="The Array Tree Map Interface." alt="" coords="795,328,945,353"/>
<area shape="rect" href="bitset_8h.html" title="The Bit Set Interface." alt="" coords="1454,328,1537,353"/>
<area shape="rect" href="buffer_8h.html" title="The Buffer Interface." alt="" coords="1127,328,1210,353"/>
<area shape="rect" href="doubly__linked__list_8h.html" title="The Doubly Linked List Interface." alt="" coords="390,328,553,353"/>
<area shape="rect" href="flat__double__ended__queue_8h.html" title="The Flat Double Ended Queue Interface." alt="" coords="969,152,1123,192"/>
<area shape="rect" href="flat__hash__map_8h.html" title="The Flat Hash Map Interface." alt="" coords="2062,328,2203,353"/>
<area shape="rect" href="flat__priority__queue_8h.html" title="The Flat Priority Queue Interface." alt="" coords="1250,159,1418,185"/>
<area shape="rect" href="priority__queue_8h.html" title="The Priority Queue Interface." alt="" coords="1575,328,1715,353"/>
<area shape="rect" href="singly__linked__list_8h.html" title="The Singly Linked List Interface." alt="" coords="1813,328,1972,353"/>
<area shape="rect" href="tree__map_8h.html" title="The Tree Map Interface." alt="" coords="2392,328,2500,353"/>
<area shape="rect" href="private__adaptive__map_8h.html" title="The Adaptive Map Private Interface." alt="" coords="5,401,188,441"/>
<area shape="rect" href="private__types_8h_source.html" title=" " alt="" coords="1089,563,1262,588"/>
<area shape="rect" href="private__array__adaptive__map_8h_source.html" title=" " alt="" coords="509,401,668,441"/>
<area shape="rect" href="private__array__tree__map_8h_source.html" title=" " alt="" coords="744,401,903,441"/>
<area shape="rect" href="private__bitset_8h_source.html" title=" " alt="" coords="1381,409,1556,434"/>
<area shape="rect" href="private__buffer_8h_source.html" title=" " alt="" coords="1080,409,1255,434"/>
<area shape="rect" href="private__doubly__linked__list_8h_source.html" title=" " alt="" coords="264,401,433,441"/>
<area shape="rect" href="private__flat__double__ended__queue_8h_source.html" title=" " alt="" coords="957,240,1135,280"/>
<area shape="rect" href="private__flat__hash__map_8h.html" title="Private Flat Hash Map Interface." alt="" coords="2170,401,2317,441"/>
<area shape="rect" href="private__flat__priority__queue_8h_source.html" title=" " alt="" coords="1261,240,1407,280"/>
<area shape="rect" href="private__priority__queue_8h_source.html" title=" " alt="" coords="1683,401,1855,441"/>
<area shape="rect" href="private__singly__linked__list_8h_source.html" title=" " alt="" coords="1931,401,2095,441"/>
<area shape="rect" href="private__tree__map_8h_source.html" title=" " alt="" coords="2443,401,2593,441"/>
</map>
</div>
</div>
<p><a href="traits_8h_source.html">Go to the source code of this file.</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The C Container Collection Traits Interface. </p>
<p>Many functionalities across containers are similar. These can be described as traits that each container implements (see Rust Traits for a more pure example of the topic). Only a selection of shared traits across containers are represented here because some containers implement unique functionality that cannot be shared with other containers. These can simplify code greatly at a slightly higher compilation resource cost. There is no runtime cost to using traits.</p>
<p>To shorten names in the interface, define the following preprocessor directive at the top of your file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define TRAITS_USING_NAMESPACE_CCC</span></div>
</div><!-- fragment --><p>All traits can then be written without the <code>CCC_</code> prefix. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Entry Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain and operate on container entries for efficient queries when non-trivial control flow is needed. </p>
</td></tr>
<tr class="memitem:aa7e463ec85c393e0bc31c026d3746e13"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#aa7e463ec85c393e0bc31c026d3746e13">CCC_swap_entry</a>(container_pointer,  swap_arguments...)&#160;&#160;&#160;    CCC_private_swap_entry(container_pointer, swap_arguments)</td></tr>
<tr class="memdesc:aa7e463ec85c393e0bc31c026d3746e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element and obtain the old value if Occupied.  <br /></td></tr>
<tr class="separator:aa7e463ec85c393e0bc31c026d3746e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5241223eb13697a7aae960f7fd5cbb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a3a5241223eb13697a7aae960f7fd5cbb">CCC_swap_entry_wrap</a>(container_pointer,  swap_arguments...)&#160;&#160;&#160;    CCC_private_swap_entry_wrap(container_pointer, swap_arguments)</td></tr>
<tr class="memdesc:a3a5241223eb13697a7aae960f7fd5cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element and obtain the old value if Occupied.  <br /></td></tr>
<tr class="separator:a3a5241223eb13697a7aae960f7fd5cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fc6824695d97967f69e057494bcb25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a36fc6824695d97967f69e057494bcb25">CCC_swap_handle</a>(container_pointer,  swap_arguments...)&#160;&#160;&#160;    CCC_private_swap_handle(container_pointer, swap_arguments)</td></tr>
<tr class="memdesc:a36fc6824695d97967f69e057494bcb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element and obtain the old value if Occupied.  <br /></td></tr>
<tr class="separator:a36fc6824695d97967f69e057494bcb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c76ac87bc31b353faf0228b803be24"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#af3c76ac87bc31b353faf0228b803be24">CCC_swap_handle_wrap</a>(container_pointer,  swap_arguments...)&#160;&#160;&#160;    CCC_private_swap_handle_wrap(container_pointer, swap_arguments)</td></tr>
<tr class="memdesc:af3c76ac87bc31b353faf0228b803be24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element and obtain the old value if Occupied.  <br /></td></tr>
<tr class="separator:af3c76ac87bc31b353faf0228b803be24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af431d49e5a606da896a5fa211890ce75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#af431d49e5a606da896a5fa211890ce75">CCC_try_insert</a>(container_pointer,  try_insert_arguments...)&#160;&#160;&#160;    CCC_private_try_insert(container_pointer, try_insert_arguments)</td></tr>
<tr class="memdesc:af431d49e5a606da896a5fa211890ce75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element if the entry is Vacant.  <br /></td></tr>
<tr class="separator:af431d49e5a606da896a5fa211890ce75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f4343b4d1deccfaf32ae3532299155"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ac2f4343b4d1deccfaf32ae3532299155">CCC_try_insert_wrap</a>(container_pointer,  try_insert_arguments...)&#160;&#160;&#160;    CCC_private_try_insert_wrap(container_pointer, try_insert_arguments)</td></tr>
<tr class="memdesc:ac2f4343b4d1deccfaf32ae3532299155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element if the entry is Vacant.  <br /></td></tr>
<tr class="separator:ac2f4343b4d1deccfaf32ae3532299155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d36b4b9edf8321ce4deea33c5308d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ac8d36b4b9edf8321ce4deea33c5308d4">CCC_insert_or_assign</a>(container_pointer,  insert_or_assign_arguments...)&#160;&#160;&#160;    CCC_private_insert_or_assign(container_pointer, insert_or_assign_arguments)</td></tr>
<tr class="memdesc:ac8d36b4b9edf8321ce4deea33c5308d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element or overwrite the Occupied entry.  <br /></td></tr>
<tr class="separator:ac8d36b4b9edf8321ce4deea33c5308d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16470ce8c7b99a1dc61ddabb2e008e1c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a16470ce8c7b99a1dc61ddabb2e008e1c">CCC_insert_or_assign_wrap</a>(container_pointer,  insert_or_assign_arguments...)</td></tr>
<tr class="memdesc:a16470ce8c7b99a1dc61ddabb2e008e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element or overwrite the Occupied entry.  <br /></td></tr>
<tr class="separator:a16470ce8c7b99a1dc61ddabb2e008e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf98612c9c130618b75ae727fb1fe150"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#adf98612c9c130618b75ae727fb1fe150">CCC_remove_key_value</a>(container_pointer,  remove_key_value_arguments...)&#160;&#160;&#160;    CCC_private_remove_key_value(container_pointer, remove_key_value_arguments)</td></tr>
<tr class="memdesc:adf98612c9c130618b75ae727fb1fe150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element and retain access to its value.  <br /></td></tr>
<tr class="separator:adf98612c9c130618b75ae727fb1fe150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4403f2a89ae5d3ec78b2b0cc5172b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a2c4403f2a89ae5d3ec78b2b0cc5172b9">CCC_remove_key_value_wrap</a>(container_pointer,  remove_key_value_arguments...)</td></tr>
<tr class="memdesc:a2c4403f2a89ae5d3ec78b2b0cc5172b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element and retain access to its value.  <br /></td></tr>
<tr class="separator:a2c4403f2a89ae5d3ec78b2b0cc5172b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2093b0d81c352dc0eb6e85a77a7ee54b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a2093b0d81c352dc0eb6e85a77a7ee54b">CCC_entry</a>(container_pointer,  key_pointer...)&#160;&#160;&#160;    CCC_private_entry(container_pointer, key_pointer)</td></tr>
<tr class="memdesc:a2093b0d81c352dc0eb6e85a77a7ee54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a container specific entry for the Entry Interface.  <br /></td></tr>
<tr class="separator:a2093b0d81c352dc0eb6e85a77a7ee54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6eb0d1bbce755e2a7c0358a30ee7890"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ab6eb0d1bbce755e2a7c0358a30ee7890">CCC_handle</a>(container_pointer,  key_pointer...)&#160;&#160;&#160;    CCC_private_handle(container_pointer, key_pointer)</td></tr>
<tr class="memdesc:ab6eb0d1bbce755e2a7c0358a30ee7890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a container specific handle for the handle Interface.  <br /></td></tr>
<tr class="separator:ab6eb0d1bbce755e2a7c0358a30ee7890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cb05888afcab07cf9340d20205d2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a14cb05888afcab07cf9340d20205d2e5">CCC_entry_wrap</a>(container_pointer,  key_pointer...)&#160;&#160;&#160;    CCC_private_entry_wrap(container_pointer, key_pointer)</td></tr>
<tr class="memdesc:a14cb05888afcab07cf9340d20205d2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a container specific entry for the Entry Interface.  <br /></td></tr>
<tr class="separator:a14cb05888afcab07cf9340d20205d2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe611ce746d1d3c4de10eb3151d8e6c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#abe611ce746d1d3c4de10eb3151d8e6c2">CCC_handle_wrap</a>(container_pointer,  key_pointer...)&#160;&#160;&#160;    CCC_private_handle_wrap(container_pointer, key_pointer)</td></tr>
<tr class="memdesc:abe611ce746d1d3c4de10eb3151d8e6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a container specific handle for the handle Interface.  <br /></td></tr>
<tr class="separator:abe611ce746d1d3c4de10eb3151d8e6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c69e9a18e4bbafb9d6e5c7327fd0e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a06c69e9a18e4bbafb9d6e5c7327fd0e8">CCC_and_modify</a>(entry_pointer,  mod_fn)&#160;&#160;&#160;    CCC_private_and_modify(entry_pointer, mod_fn)</td></tr>
<tr class="memdesc:a06c69e9a18e4bbafb9d6e5c7327fd0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify an entry if Occupied.  <br /></td></tr>
<tr class="separator:a06c69e9a18e4bbafb9d6e5c7327fd0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a879e1ce61a86c14d35aa236279cba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a86a879e1ce61a86c14d35aa236279cba">CCC_and_context_modify</a>(entry_pointer,  modify,  context_arguments...)&#160;&#160;&#160;    CCC_private_and_context_modify(entry_pointer, modify, context_arguments)</td></tr>
<tr class="memdesc:a86a879e1ce61a86c14d35aa236279cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify an entry if Occupied.  <br /></td></tr>
<tr class="separator:a86a879e1ce61a86c14d35aa236279cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cce635dbfc91154cf7002a71d639cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ab5cce635dbfc91154cf7002a71d639cc">CCC_insert_entry</a>(entry_pointer,  insert_entry_arguments...)&#160;&#160;&#160;    CCC_private_insert_entry(entry_pointer, insert_entry_arguments)</td></tr>
<tr class="memdesc:ab5cce635dbfc91154cf7002a71d639cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element or overwrite old element.  <br /></td></tr>
<tr class="separator:ab5cce635dbfc91154cf7002a71d639cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3406c1125540e36828a9418b71b073"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a2e3406c1125540e36828a9418b71b073">CCC_insert_handle</a>(array_pointer,  insert_array_arguments...)&#160;&#160;&#160;    CCC_private_insert_handle(array_pointer, insert_array_arguments)</td></tr>
<tr class="memdesc:a2e3406c1125540e36828a9418b71b073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element or overwrite old element.  <br /></td></tr>
<tr class="separator:a2e3406c1125540e36828a9418b71b073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf79b31383d758bc76e5fb20fd82ec1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a3cf79b31383d758bc76e5fb20fd82ec1">CCC_or_insert</a>(entry_pointer,  or_insert_arguments...)&#160;&#160;&#160;    CCC_private_or_insert(entry_pointer, or_insert_arguments)</td></tr>
<tr class="memdesc:a3cf79b31383d758bc76e5fb20fd82ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new element if the entry is Vacant.  <br /></td></tr>
<tr class="separator:a3cf79b31383d758bc76e5fb20fd82ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac207035aea4cbe0c51d16589c2460db4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ac207035aea4cbe0c51d16589c2460db4">CCC_remove_entry</a>(entry_pointer)&#160;&#160;&#160;CCC_private_remove_entry(entry_pointer)</td></tr>
<tr class="memdesc:ac207035aea4cbe0c51d16589c2460db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element if the entry is Occupied.  <br /></td></tr>
<tr class="separator:ac207035aea4cbe0c51d16589c2460db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e80401338bc7980d63b75bf9c8cc108"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a4e80401338bc7980d63b75bf9c8cc108">CCC_remove_entry_wrap</a>(entry_pointer)&#160;&#160;&#160;    CCC_private_remove_entry_wrap(entry_pointer)</td></tr>
<tr class="memdesc:a4e80401338bc7980d63b75bf9c8cc108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element if the entry is Occupied.  <br /></td></tr>
<tr class="separator:a4e80401338bc7980d63b75bf9c8cc108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a9141ace02d75b61a40e78fb070e08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a81a9141ace02d75b61a40e78fb070e08">CCC_remove_handle</a>(array_pointer)&#160;&#160;&#160;    CCC_private_remove_handle(array_pointer)</td></tr>
<tr class="memdesc:a81a9141ace02d75b61a40e78fb070e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element if the handle is Occupied.  <br /></td></tr>
<tr class="separator:a81a9141ace02d75b61a40e78fb070e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe3201d00f81e4ef8b5d060086561da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a8fe3201d00f81e4ef8b5d060086561da">CCC_remove_handle_wrap</a>(array_pointer)&#160;&#160;&#160;    CCC_private_remove_handle_wrap(array_pointer)</td></tr>
<tr class="memdesc:a8fe3201d00f81e4ef8b5d060086561da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element if the handle is Occupied.  <br /></td></tr>
<tr class="separator:a8fe3201d00f81e4ef8b5d060086561da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42510f7ed011f774d3549ef3c91d4a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ab42510f7ed011f774d3549ef3c91d4a2">CCC_unwrap</a>(entry_pointer)&#160;&#160;&#160;CCC_private_unwrap(entry_pointer)</td></tr>
<tr class="memdesc:ab42510f7ed011f774d3549ef3c91d4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwrap user type in entry.  <br /></td></tr>
<tr class="separator:ab42510f7ed011f774d3549ef3c91d4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ffeab920e9fb81fb185004e4e22f60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a98ffeab920e9fb81fb185004e4e22f60">CCC_occupied</a>(entry_pointer)&#160;&#160;&#160;CCC_private_occupied(entry_pointer)</td></tr>
<tr class="memdesc:a98ffeab920e9fb81fb185004e4e22f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check occupancy of entry.  <br /></td></tr>
<tr class="separator:a98ffeab920e9fb81fb185004e4e22f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0478c724a9aa16943c6515b95a4c5c83"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a0478c724a9aa16943c6515b95a4c5c83">CCC_insert_error</a>(entry_pointer)&#160;&#160;&#160;CCC_private_insert_error(entry_pointer)</td></tr>
<tr class="memdesc:a0478c724a9aa16943c6515b95a4c5c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check last insert status.  <br /></td></tr>
<tr class="separator:a0478c724a9aa16943c6515b95a4c5c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Membership Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Test membership or obtain references to stored user types directly. </p>
</td></tr>
<tr class="memitem:a4a81daea52cfe16f59ff00d87015b106"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a4a81daea52cfe16f59ff00d87015b106">CCC_get_key_value</a>(container_pointer,  key_pointer...)&#160;&#160;&#160;    CCC_private_get_key_value(container_pointer, key_pointer)</td></tr>
<tr class="memdesc:a4a81daea52cfe16f59ff00d87015b106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the user type stored at the key.  <br /></td></tr>
<tr class="separator:a4a81daea52cfe16f59ff00d87015b106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a399d979c7e3e284ddb395d6a42487"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ae4a399d979c7e3e284ddb395d6a42487">CCC_contains</a>(container_pointer,  key_pointer...)&#160;&#160;&#160;    CCC_private_contains(container_pointer, key_pointer)</td></tr>
<tr class="memdesc:ae4a399d979c7e3e284ddb395d6a42487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for membership of the key.  <br /></td></tr>
<tr class="separator:ae4a399d979c7e3e284ddb395d6a42487"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Push Pop Front Back Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Push, pop, and view elements in sorted or unsorted containers. </p>
</td></tr>
<tr class="memitem:ac5bdeefd70bfdffa2190329deb21ab8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ac5bdeefd70bfdffa2190329deb21ab8b">CCC_push</a>(container_pointer,  push_arguments...)&#160;&#160;&#160;    CCC_private_push(container_pointer, push_arguments)</td></tr>
<tr class="memdesc:ac5bdeefd70bfdffa2190329deb21ab8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element into a container.  <br /></td></tr>
<tr class="separator:ac5bdeefd70bfdffa2190329deb21ab8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f377a663decd0421b962bbc26da512f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a2f377a663decd0421b962bbc26da512f">CCC_push_back</a>(container_pointer,  push_arguments...)&#160;&#160;&#160;    CCC_private_push_back(container_pointer, push_arguments)</td></tr>
<tr class="memdesc:a2f377a663decd0421b962bbc26da512f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the back of a container.  <br /></td></tr>
<tr class="separator:a2f377a663decd0421b962bbc26da512f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bacf413e77ba2800653acc7bfe4ede"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#af2bacf413e77ba2800653acc7bfe4ede">CCC_push_front</a>(container_pointer,  push_arguments...)&#160;&#160;&#160;    CCC_private_push_front(container_pointer, push_arguments)</td></tr>
<tr class="memdesc:af2bacf413e77ba2800653acc7bfe4ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the front of a container.  <br /></td></tr>
<tr class="separator:af2bacf413e77ba2800653acc7bfe4ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060c9cc6826bb39350be21750233ce71"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a060c9cc6826bb39350be21750233ce71">CCC_pop</a>(container_pointer,  pop_arguments...)&#160;&#160;&#160;    CCC_private_pop(container_pointer, pop_arguments)</td></tr>
<tr class="memdesc:a060c9cc6826bb39350be21750233ce71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an element from a container.  <br /></td></tr>
<tr class="separator:a060c9cc6826bb39350be21750233ce71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6ea07e914d9bdd03424c39082299e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#adc6ea07e914d9bdd03424c39082299e5">CCC_pop_front</a>(container_pointer)&#160;&#160;&#160;    CCC_private_pop_front(container_pointer)</td></tr>
<tr class="memdesc:adc6ea07e914d9bdd03424c39082299e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an element from the front of a container.  <br /></td></tr>
<tr class="separator:adc6ea07e914d9bdd03424c39082299e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddf2fb67b4322c8cb48a7ecf09f3115"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a9ddf2fb67b4322c8cb48a7ecf09f3115">CCC_pop_back</a>(container_pointer)&#160;&#160;&#160;CCC_private_pop_back(container_pointer)</td></tr>
<tr class="memdesc:a9ddf2fb67b4322c8cb48a7ecf09f3115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an element from the back of a container.  <br /></td></tr>
<tr class="separator:a9ddf2fb67b4322c8cb48a7ecf09f3115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5072ddc807149d24311ff1729a5c1c60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a5072ddc807149d24311ff1729a5c1c60">CCC_front</a>(container_pointer)&#160;&#160;&#160;CCC_private_front(container_pointer)</td></tr>
<tr class="memdesc:a5072ddc807149d24311ff1729a5c1c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference the front element of a container.  <br /></td></tr>
<tr class="separator:a5072ddc807149d24311ff1729a5c1c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55359b1a71f993ab27c2f267012a62c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a55359b1a71f993ab27c2f267012a62c2">CCC_back</a>(container_pointer)&#160;&#160;&#160;CCC_private_back(container_pointer)</td></tr>
<tr class="memdesc:a55359b1a71f993ab27c2f267012a62c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference the back element of a container.  <br /></td></tr>
<tr class="separator:a55359b1a71f993ab27c2f267012a62c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8b655cc1c871d1d86de0e2ab403e40"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#afd8b655cc1c871d1d86de0e2ab403e40">CCC_splice</a>(container_pointer,  splice_arguments...)&#160;&#160;&#160;    CCC_private_splice(container_pointer, splice_arguments)</td></tr>
<tr class="memdesc:afd8b655cc1c871d1d86de0e2ab403e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splice an element from one position to another in the same or a different container.  <br /></td></tr>
<tr class="separator:afd8b655cc1c871d1d86de0e2ab403e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7480fbdf342099370c59d90a1f386b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a7d7480fbdf342099370c59d90a1f386b">CCC_splice_range</a>(container_pointer,  splice_arguments...)&#160;&#160;&#160;    CCC_private_splice_range(container_pointer, splice_arguments)</td></tr>
<tr class="memdesc:a7d7480fbdf342099370c59d90a1f386b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splice a range of elements from one position to another in the same or a different container.  <br /></td></tr>
<tr class="separator:a7d7480fbdf342099370c59d90a1f386b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Priority Queue Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Interface to support generic priority queue operations. </p>
</td></tr>
<tr class="memitem:a9d71f5910f431f9336e6568dc3ef80b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a9d71f5910f431f9336e6568dc3ef80b2">CCC_update</a>(container_pointer,  update_arguments...)&#160;&#160;&#160;    CCC_private_update(container_pointer, update_arguments)</td></tr>
<tr class="memdesc:a9d71f5910f431f9336e6568dc3ef80b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of an element known to be in a container.  <br /></td></tr>
<tr class="separator:a9d71f5910f431f9336e6568dc3ef80b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234d5e7b5daae822c535805b5779c73d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a234d5e7b5daae822c535805b5779c73d">CCC_increase</a>(container_pointer,  increase_arguments...)&#160;&#160;&#160;    CCC_private_increase(container_pointer, increase_arguments)</td></tr>
<tr class="memdesc:a234d5e7b5daae822c535805b5779c73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the value of an element known to be in a container.  <br /></td></tr>
<tr class="separator:a234d5e7b5daae822c535805b5779c73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32fc447c5a18da8d7ad0b52ced61ede"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#aa32fc447c5a18da8d7ad0b52ced61ede">CCC_decrease</a>(container_pointer,  decrease_arguments...)&#160;&#160;&#160;    CCC_private_decrease(container_pointer, decrease_arguments)</td></tr>
<tr class="memdesc:aa32fc447c5a18da8d7ad0b52ced61ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the value of an element known to be in a container.  <br /></td></tr>
<tr class="separator:aa32fc447c5a18da8d7ad0b52ced61ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0986a36c3d0e39e87183081223ccec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a7e0986a36c3d0e39e87183081223ccec">CCC_erase</a>(container_pointer,  erase_arguments...)&#160;&#160;&#160;    CCC_private_erase(container_pointer, erase_arguments)</td></tr>
<tr class="memdesc:a7e0986a36c3d0e39e87183081223ccec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an element known to be in a container.  <br /></td></tr>
<tr class="separator:a7e0986a36c3d0e39e87183081223ccec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f45716d00ee674db1b94e964f3b24f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ae7f45716d00ee674db1b94e964f3b24f">CCC_extract</a>(container_pointer,  extract_arguments...)&#160;&#160;&#160;    CCC_private_extract(container_pointer, extract_arguments)</td></tr>
<tr class="memdesc:ae7f45716d00ee674db1b94e964f3b24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract an element known to be in a container (does not free).  <br /></td></tr>
<tr class="separator:ae7f45716d00ee674db1b94e964f3b24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef7825d32ca85011aea525d18b8fbd5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#aeef7825d32ca85011aea525d18b8fbd5">CCC_extract_range</a>(container_pointer,  extract_arguments...)&#160;&#160;&#160;    CCC_private_extract_range(container_pointer, extract_arguments)</td></tr>
<tr class="memdesc:aeef7825d32ca85011aea525d18b8fbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract elements known to be in a container (does not free).  <br /></td></tr>
<tr class="separator:aeef7825d32ca85011aea525d18b8fbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Iterator Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain and manage iterators over the container. </p>
</td></tr>
<tr class="memitem:a7cafec411ee3f60bc10033bb8abf7ac4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a7cafec411ee3f60bc10033bb8abf7ac4">CCC_begin</a>(container_pointer)&#160;&#160;&#160;CCC_private_begin(container_pointer)</td></tr>
<tr class="memdesc:a7cafec411ee3f60bc10033bb8abf7ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the start of a container.  <br /></td></tr>
<tr class="separator:a7cafec411ee3f60bc10033bb8abf7ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6237dcd969f191f580d65d7fd63be4c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a6237dcd969f191f580d65d7fd63be4c5">CCC_reverse_begin</a>(container_pointer)&#160;&#160;&#160;    CCC_private_reverse_begin(container_pointer)</td></tr>
<tr class="memdesc:a6237dcd969f191f580d65d7fd63be4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the reversed start of a container.  <br /></td></tr>
<tr class="separator:a6237dcd969f191f580d65d7fd63be4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2e1d8eb494bca89d88a171b4a3ab5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a1a2e1d8eb494bca89d88a171b4a3ab5d">CCC_next</a>(container_pointer,  void_iterator_pointer)&#160;&#160;&#160;    CCC_private_next(container_pointer, void_iterator_pointer)</td></tr>
<tr class="memdesc:a1a2e1d8eb494bca89d88a171b4a3ab5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the next element in the container.  <br /></td></tr>
<tr class="separator:a1a2e1d8eb494bca89d88a171b4a3ab5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fab7d4aca5df5547f4474095f18b40a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a1fab7d4aca5df5547f4474095f18b40a">CCC_reverse_next</a>(container_pointer,  void_iterator_pointer)&#160;&#160;&#160;    CCC_private_reverse_next(container_pointer, void_iterator_pointer)</td></tr>
<tr class="memdesc:a1fab7d4aca5df5547f4474095f18b40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the reverse_next element in the container.  <br /></td></tr>
<tr class="separator:a1fab7d4aca5df5547f4474095f18b40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f69c818b648fb9d44f3807d72f9653a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a4f69c818b648fb9d44f3807d72f9653a">CCC_end</a>(container_pointer)&#160;&#160;&#160;CCC_private_end(container_pointer)</td></tr>
<tr class="memdesc:a4f69c818b648fb9d44f3807d72f9653a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the end sentinel of a container.  <br /></td></tr>
<tr class="separator:a4f69c818b648fb9d44f3807d72f9653a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e882e40fee89407d607872f31814381"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a4e882e40fee89407d607872f31814381">CCC_reverse_end</a>(container_pointer)&#160;&#160;&#160;    CCC_private_reverse_end(container_pointer)</td></tr>
<tr class="memdesc:a4e882e40fee89407d607872f31814381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the reverse_end sentinel of a container.  <br /></td></tr>
<tr class="separator:a4e882e40fee89407d607872f31814381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9deab37d55c0666a5f83dd673a7edfe4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a9deab37d55c0666a5f83dd673a7edfe4">CCC_equal_range</a>(container_pointer,  range_arguments...)&#160;&#160;&#160;    CCC_private_equal_range(container_pointer, range_arguments)</td></tr>
<tr class="memdesc:a9deab37d55c0666a5f83dd673a7edfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a range of values from a container.  <br /></td></tr>
<tr class="separator:a9deab37d55c0666a5f83dd673a7edfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d2d1704c91a403532921fad59c9f94"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a64d2d1704c91a403532921fad59c9f94">CCC_equal_range_wrap</a>(container_pointer,  range_arguments...)&#160;&#160;&#160;    CCC_private_equal_range_wrap(container_pointer, range_arguments)</td></tr>
<tr class="memdesc:a64d2d1704c91a403532921fad59c9f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a range of values from a container.  <br /></td></tr>
<tr class="separator:a64d2d1704c91a403532921fad59c9f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad349221e6d7e3a9a619ebe7e365a4a71"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ad349221e6d7e3a9a619ebe7e365a4a71">CCC_equal_range_reverse</a>(container_pointer,  range_reverse_arguments...)&#160;&#160;&#160;    CCC_private_equal_range_reverse(container_pointer, range_reverse_arguments)</td></tr>
<tr class="memdesc:ad349221e6d7e3a9a619ebe7e365a4a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a range_reverse of values from a container.  <br /></td></tr>
<tr class="separator:ad349221e6d7e3a9a619ebe7e365a4a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa423753fc40870991b2adaea33c34576"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#aa423753fc40870991b2adaea33c34576">CCC_equal_range_reverse_wrap</a>(container_pointer,  range_reverse_arguments...)</td></tr>
<tr class="memdesc:aa423753fc40870991b2adaea33c34576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a range_reverse of values from a container.  <br /></td></tr>
<tr class="separator:aa423753fc40870991b2adaea33c34576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e153edc4d813aeb8fcba9640c53d1a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#af1e153edc4d813aeb8fcba9640c53d1a">CCC_range_begin</a>(range_pointer)&#160;&#160;&#160;CCC_private_range_begin(range_pointer)</td></tr>
<tr class="memdesc:af1e153edc4d813aeb8fcba9640c53d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the beginning of the range iterator.  <br /></td></tr>
<tr class="separator:af1e153edc4d813aeb8fcba9640c53d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645dbec6c02190de14248d44ed642412"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a645dbec6c02190de14248d44ed642412">CCC_range_end</a>(range_pointer)&#160;&#160;&#160;CCC_private_range_end(range_pointer)</td></tr>
<tr class="memdesc:a645dbec6c02190de14248d44ed642412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the end of the range iterator.  <br /></td></tr>
<tr class="separator:a645dbec6c02190de14248d44ed642412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad055a9c9c00366a2fb4f4a5941a47adc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ad055a9c9c00366a2fb4f4a5941a47adc">CCC_range_reverse_begin</a>(range_reverse_pointer)&#160;&#160;&#160;    CCC_private_range_reverse_begin(range_reverse_pointer)</td></tr>
<tr class="memdesc:ad055a9c9c00366a2fb4f4a5941a47adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the beginning of the reverse range iterator.  <br /></td></tr>
<tr class="separator:ad055a9c9c00366a2fb4f4a5941a47adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb020bf9603590a7175222e57871291"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a9cb020bf9603590a7175222e57871291">CCC_range_reverse_end</a>(range_reverse_pointer)&#160;&#160;&#160;    CCC_private_range_reverse_end(range_reverse_pointer)</td></tr>
<tr class="memdesc:a9cb020bf9603590a7175222e57871291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the end of the reverse range iterator.  <br /></td></tr>
<tr class="separator:a9cb020bf9603590a7175222e57871291"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Memory Management Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Manage underlying buffers for containers. </p>
</td></tr>
<tr class="memitem:aeeb8fd6d1430bdf51d395413fc00f893"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#aeeb8fd6d1430bdf51d395413fc00f893">CCC_copy</a>(destination_container_pointer,  source_container_pointer,  allocate_pointer)</td></tr>
<tr class="memdesc:aeeb8fd6d1430bdf51d395413fc00f893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy source containers memory to destination container.  <br /></td></tr>
<tr class="separator:aeeb8fd6d1430bdf51d395413fc00f893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716f00ed6954d4ba8ef0e122f7f20e65"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a716f00ed6954d4ba8ef0e122f7f20e65">CCC_reserve</a>(container_pointer,  n_to_add,  allocate_pointer)&#160;&#160;&#160;    CCC_private_reserve(container_pointer, n_to_add, allocate_pointer)</td></tr>
<tr class="memdesc:a716f00ed6954d4ba8ef0e122f7f20e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve capacity for n_to_add new elements to be inserted.  <br /></td></tr>
<tr class="separator:a716f00ed6954d4ba8ef0e122f7f20e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130256931b2dc99e81678cf638c6a6af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a130256931b2dc99e81678cf638c6a6af">CCC_clear</a>(container_pointer,  destructor_arguments...)&#160;&#160;&#160;    CCC_private_clear(container_pointer, destructor_arguments)</td></tr>
<tr class="memdesc:a130256931b2dc99e81678cf638c6a6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container without freeing the underlying buffer.  <br /></td></tr>
<tr class="separator:a130256931b2dc99e81678cf638c6a6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb14bff9df8d582487fe08da686eaa7b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#adb14bff9df8d582487fe08da686eaa7b">CCC_clear_and_free</a>(container_pointer,  destructor_and_free_arguments...)&#160;&#160;&#160;    CCC_private_clear_and_free(container_pointer, destructor_and_free_arguments)</td></tr>
<tr class="memdesc:adb14bff9df8d582487fe08da686eaa7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container and frees the underlying buffer.  <br /></td></tr>
<tr class="separator:adb14bff9df8d582487fe08da686eaa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047e322b64da0a2a6f375ef887c57923"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a047e322b64da0a2a6f375ef887c57923">CCC_clear_and_free_reserve</a>(container_pointer,  destructor_and_free_arguments...)</td></tr>
<tr class="memdesc:a047e322b64da0a2a6f375ef887c57923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container previously reserved and frees its underlying buffer. Covers the case of a one-time memory reserved container that does not otherwise have permissions over its own memory to resize or free.  <br /></td></tr>
<tr class="separator:a047e322b64da0a2a6f375ef887c57923"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">State Interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain the container state. </p>
</td></tr>
<tr class="memitem:a677dc640ef165bb424bd911d7fc32aa3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a677dc640ef165bb424bd911d7fc32aa3">CCC_count</a>(container_pointer)&#160;&#160;&#160;CCC_private_count(container_pointer)</td></tr>
<tr class="memdesc:a677dc640ef165bb424bd911d7fc32aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the count of elements in the container.  <br /></td></tr>
<tr class="separator:a677dc640ef165bb424bd911d7fc32aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b2442930285cb2343ec96593776759"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#ae6b2442930285cb2343ec96593776759">CCC_capacity</a>(container_pointer)&#160;&#160;&#160;CCC_private_capacity(container_pointer)</td></tr>
<tr class="memdesc:ae6b2442930285cb2343ec96593776759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the capacity of the container.  <br /></td></tr>
<tr class="separator:ae6b2442930285cb2343ec96593776759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3926a950b876a4ab6a2ca3d5e157a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a0c3926a950b876a4ab6a2ca3d5e157a2">CCC_is_empty</a>(container_pointer)&#160;&#160;&#160;CCC_private_is_empty(container_pointer)</td></tr>
<tr class="memdesc:a0c3926a950b876a4ab6a2ca3d5e157a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size status of a container.  <br /></td></tr>
<tr class="separator:a0c3926a950b876a4ab6a2ca3d5e157a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e45c5f2d2e0a1221ce6310dfee7bce5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8h.html#a8e45c5f2d2e0a1221ce6310dfee7bce5">CCC_validate</a>(container_pointer)&#160;&#160;&#160;CCC_private_validate(container_pointer)</td></tr>
<tr class="memdesc:a8e45c5f2d2e0a1221ce6310dfee7bce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the invariant statuses of the container.  <br /></td></tr>
<tr class="separator:a8e45c5f2d2e0a1221ce6310dfee7bce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a86a879e1ce61a86c14d35aa236279cba" name="a86a879e1ce61a86c14d35aa236279cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a879e1ce61a86c14d35aa236279cba">&#9670;&#160;</a></span>CCC_and_context_modify</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_and_context_modify</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">modify, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_and_context_modify(entry_pointer, modify, context_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify an entry if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modify</td><td>a modification function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context_arguments</td><td>context data for mod_fn. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the modified entry if Occupied or original if Vacant.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a06c69e9a18e4bbafb9d6e5c7327fd0e8" name="a06c69e9a18e4bbafb9d6e5c7327fd0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c69e9a18e4bbafb9d6e5c7327fd0e8">&#9670;&#160;</a></span>CCC_and_modify</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_and_modify</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mod_fn&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_and_modify(entry_pointer, mod_fn)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify an entry if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mod_fn</td><td>a modification function that does not need context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the modified entry if Occupied or original if Vacant.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a55359b1a71f993ab27c2f267012a62c2" name="a55359b1a71f993ab27c2f267012a62c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55359b1a71f993ab27c2f267012a62c2">&#9670;&#160;</a></span>CCC_back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_back(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference the back element of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to a user type.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a7cafec411ee3f60bc10033bb8abf7ac4" name="a7cafec411ee3f60bc10033bb8abf7ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cafec411ee3f60bc10033bb8abf7ac4">&#9670;&#160;</a></span>CCC_begin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_begin</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_begin(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the start of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the user type stored at the start.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ae6b2442930285cb2343ec96593776759" name="ae6b2442930285cb2343ec96593776759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b2442930285cb2343ec96593776759">&#9670;&#160;</a></span>CCC_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_capacity</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_capacity(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the capacity of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the capacity or an argument error is set if container_pointer is NULL.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a130256931b2dc99e81678cf638c6a6af" name="a130256931b2dc99e81678cf638c6a6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130256931b2dc99e81678cf638c6a6af">&#9670;&#160;</a></span>CCC_clear</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_clear</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">destructor_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_clear(container_pointer, destructor_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the container without freeing the underlying buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destructor_arguments</td><td>optional function to be called on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="adb14bff9df8d582487fe08da686eaa7b" name="adb14bff9df8d582487fe08da686eaa7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb14bff9df8d582487fe08da686eaa7b">&#9670;&#160;</a></span>CCC_clear_and_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_clear_and_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">destructor_and_free_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_clear_and_free(container_pointer, destructor_and_free_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the container and frees the underlying buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destructor_and_free_arguments</td><td>optional function to be called on each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a047e322b64da0a2a6f375ef887c57923" name="a047e322b64da0a2a6f375ef887c57923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047e322b64da0a2a6f375ef887c57923">&#9670;&#160;</a></span>CCC_clear_and_free_reserve</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_clear_and_free_reserve</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">destructor_and_free_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_clear_and_free_reserve(container_pointer,                      \</div>
<div class="line">                                       destructor_and_free_arguments)</div>
</div><!-- fragment -->
<p>Clears the container previously reserved and frees its underlying buffer. Covers the case of a one-time memory reserved container that does not otherwise have permissions over its own memory to resize or free. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destructor_and_free_arguments</td><td>optional destructor function to be called on each element and the required allocation function to free memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ae4a399d979c7e3e284ddb395d6a42487" name="ae4a399d979c7e3e284ddb395d6a42487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a399d979c7e3e284ddb395d6a42487">&#9670;&#160;</a></span>CCC_contains</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_contains</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_pointer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_contains(container_pointer, key_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for membership of the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_pointer</td><td>a pointer to the search key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if present false if absent.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="aeeb8fd6d1430bdf51d395413fc00f893" name="aeeb8fd6d1430bdf51d395413fc00f893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb8fd6d1430bdf51d395413fc00f893">&#9670;&#160;</a></span>CCC_copy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_copy</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">destination_container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">source_container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_copy(destination_container_pointer, source_container_pointer,  \</div>
<div class="line">                     allocate_pointer)</div>
</div><!-- fragment -->
<p>Copy source containers memory to destination container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destination_container_pointer</td><td>a pointer to the destination container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_container_pointer</td><td>a pointer to the source container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate_pointer</td><td>the allocation function to use for resizing if needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a677dc640ef165bb424bd911d7fc32aa3" name="a677dc640ef165bb424bd911d7fc32aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677dc640ef165bb424bd911d7fc32aa3">&#9670;&#160;</a></span>CCC_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_count</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_count(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the count of elements in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size or an argument error is set if container_pointer is NULL.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="aa32fc447c5a18da8d7ad0b52ced61ede" name="aa32fc447c5a18da8d7ad0b52ced61ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32fc447c5a18da8d7ad0b52ced61ede">&#9670;&#160;</a></span>CCC_decrease</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_decrease</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">decrease_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_decrease(container_pointer, decrease_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the value of an element known to be in a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">decrease_arguments</td><td>depend on the container.</td></tr>
  </table>
  </dd>
</dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a4f69c818b648fb9d44f3807d72f9653a" name="a4f69c818b648fb9d44f3807d72f9653a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f69c818b648fb9d44f3807d72f9653a">&#9670;&#160;</a></span>CCC_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_end</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_end(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the end sentinel of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the end sentinel.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a2093b0d81c352dc0eb6e85a77a7ee54b" name="a2093b0d81c352dc0eb6e85a77a7ee54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2093b0d81c352dc0eb6e85a77a7ee54b">&#9670;&#160;</a></span>CCC_entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_entry</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_pointer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_entry(container_pointer, key_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a container specific entry for the Entry Interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_pointer</td><td>a pointer to the search key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container specific entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a14cb05888afcab07cf9340d20205d2e5" name="a14cb05888afcab07cf9340d20205d2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14cb05888afcab07cf9340d20205d2e5">&#9670;&#160;</a></span>CCC_entry_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_entry_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_pointer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_entry_wrap(container_pointer, key_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a container specific entry for the Entry Interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_pointer</td><td>a pointer to the search key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container specific entry reference depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a9deab37d55c0666a5f83dd673a7edfe4" name="a9deab37d55c0666a5f83dd673a7edfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9deab37d55c0666a5f83dd673a7edfe4">&#9670;&#160;</a></span>CCC_equal_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_equal_range</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_equal_range(container_pointer, range_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a range of values from a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">range_arguments</td><td>are container specific. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ad349221e6d7e3a9a619ebe7e365a4a71" name="ad349221e6d7e3a9a619ebe7e365a4a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad349221e6d7e3a9a619ebe7e365a4a71">&#9670;&#160;</a></span>CCC_equal_range_reverse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_equal_range_reverse</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_reverse_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_equal_range_reverse(container_pointer, range_reverse_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a range_reverse of values from a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">range_reverse_arguments</td><td>are container specific. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range_reverse.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="aa423753fc40870991b2adaea33c34576" name="aa423753fc40870991b2adaea33c34576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa423753fc40870991b2adaea33c34576">&#9670;&#160;</a></span>CCC_equal_range_reverse_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_equal_range_reverse_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_reverse_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_equal_range_reverse_wrap(container_pointer,                    \</div>
<div class="line">                                         range_reverse_arguments)</div>
</div><!-- fragment -->
<p>Obtain a range_reverse of values from a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">range_reverse_arguments</td><td>are container specific. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the range_reverse.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a64d2d1704c91a403532921fad59c9f94" name="a64d2d1704c91a403532921fad59c9f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d2d1704c91a403532921fad59c9f94">&#9670;&#160;</a></span>CCC_equal_range_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_equal_range_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_equal_range_wrap(container_pointer, range_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a range of values from a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">range_arguments</td><td>are container specific. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the range.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a7e0986a36c3d0e39e87183081223ccec" name="a7e0986a36c3d0e39e87183081223ccec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0986a36c3d0e39e87183081223ccec">&#9670;&#160;</a></span>CCC_erase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_erase</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">erase_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_erase(container_pointer, erase_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase an element known to be in a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">erase_arguments</td><td>depend on the container.</td></tr>
  </table>
  </dd>
</dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ae7f45716d00ee674db1b94e964f3b24f" name="ae7f45716d00ee674db1b94e964f3b24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f45716d00ee674db1b94e964f3b24f">&#9670;&#160;</a></span>CCC_extract</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_extract</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">extract_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_extract(container_pointer, extract_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract an element known to be in a container (does not free). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">extract_arguments</td><td>depend on the container.</td></tr>
  </table>
  </dd>
</dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="aeef7825d32ca85011aea525d18b8fbd5" name="aeef7825d32ca85011aea525d18b8fbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef7825d32ca85011aea525d18b8fbd5">&#9670;&#160;</a></span>CCC_extract_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_extract_range</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">extract_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_extract_range(container_pointer, extract_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract elements known to be in a container (does not free). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">extract_arguments</td><td>depend on the container.</td></tr>
  </table>
  </dd>
</dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a5072ddc807149d24311ff1729a5c1c60" name="a5072ddc807149d24311ff1729a5c1c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5072ddc807149d24311ff1729a5c1c60">&#9670;&#160;</a></span>CCC_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_front</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_front(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference the front element of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to a user type.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a4a81daea52cfe16f59ff00d87015b106" name="a4a81daea52cfe16f59ff00d87015b106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a81daea52cfe16f59ff00d87015b106">&#9670;&#160;</a></span>CCC_get_key_value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_get_key_value</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_pointer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_get_key_value(container_pointer, key_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the user type stored at the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_pointer</td><td>a pointer to the search key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the stored user type or NULL of absent.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ab6eb0d1bbce755e2a7c0358a30ee7890" name="ab6eb0d1bbce755e2a7c0358a30ee7890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6eb0d1bbce755e2a7c0358a30ee7890">&#9670;&#160;</a></span>CCC_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_handle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_pointer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_handle(container_pointer, key_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a container specific handle for the handle Interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_pointer</td><td>a pointer to the search key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container specific handle depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="abe611ce746d1d3c4de10eb3151d8e6c2" name="abe611ce746d1d3c4de10eb3151d8e6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe611ce746d1d3c4de10eb3151d8e6c2">&#9670;&#160;</a></span>CCC_handle_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_handle_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key_pointer...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_handle_wrap(container_pointer, key_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a container specific handle for the handle Interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_pointer</td><td>a pointer to the search key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container specific handle reference depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a234d5e7b5daae822c535805b5779c73d" name="a234d5e7b5daae822c535805b5779c73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234d5e7b5daae822c535805b5779c73d">&#9670;&#160;</a></span>CCC_increase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_increase</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">increase_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_increase(container_pointer, increase_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the value of an element known to be in a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">increase_arguments</td><td>depend on the container.</td></tr>
  </table>
  </dd>
</dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ab5cce635dbfc91154cf7002a71d639cc" name="ab5cce635dbfc91154cf7002a71d639cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5cce635dbfc91154cf7002a71d639cc">&#9670;&#160;</a></span>CCC_insert_entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_insert_entry</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">insert_entry_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_insert_entry(entry_pointer, insert_entry_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert new element or overwrite old element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">insert_entry_arguments</td><td>arguments depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an reference to the inserted element.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a0478c724a9aa16943c6515b95a4c5c83" name="a0478c724a9aa16943c6515b95a4c5c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0478c724a9aa16943c6515b95a4c5c83">&#9670;&#160;</a></span>CCC_insert_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_insert_error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_insert_error(entry_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check last insert status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an insert error occurred false if not.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a2e3406c1125540e36828a9418b71b073" name="a2e3406c1125540e36828a9418b71b073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3406c1125540e36828a9418b71b073">&#9670;&#160;</a></span>CCC_insert_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_insert_handle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">array_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">insert_array_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_insert_handle(array_pointer, insert_array_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert new element or overwrite old element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">insert_array_arguments</td><td>arguments depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an reference to the inserted element.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ac8d36b4b9edf8321ce4deea33c5308d4" name="ac8d36b4b9edf8321ce4deea33c5308d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d36b4b9edf8321ce4deea33c5308d4">&#9670;&#160;</a></span>CCC_insert_or_assign</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_insert_or_assign</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">insert_or_assign_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_insert_or_assign(container_pointer, insert_or_assign_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element or overwrite the Occupied entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">insert_or_assign_arguments</td><td>arguments depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a16470ce8c7b99a1dc61ddabb2e008e1c" name="a16470ce8c7b99a1dc61ddabb2e008e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16470ce8c7b99a1dc61ddabb2e008e1c">&#9670;&#160;</a></span>CCC_insert_or_assign_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_insert_or_assign_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">insert_or_assign_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_insert_or_assign_wrap(container_pointer,                       \</div>
<div class="line">                                      insert_or_assign_arguments)</div>
</div><!-- fragment -->
<p>Insert an element or overwrite the Occupied entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">insert_or_assign_arguments</td><td>arguments depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a0c3926a950b876a4ab6a2ca3d5e157a2" name="a0c3926a950b876a4ab6a2ca3d5e157a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3926a950b876a4ab6a2ca3d5e157a2">&#9670;&#160;</a></span>CCC_is_empty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_is_empty</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_is_empty(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size status of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if empty or NULL false if not.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a1a2e1d8eb494bca89d88a171b4a3ab5d" name="a1a2e1d8eb494bca89d88a171b4a3ab5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2e1d8eb494bca89d88a171b4a3ab5d">&#9670;&#160;</a></span>CCC_next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_next</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">void_iterator_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_next(container_pointer, void_iterator_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the next element in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void_iterator_pointer</td><td>the user type returned from the last iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the user type stored next.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a98ffeab920e9fb81fb185004e4e22f60" name="a98ffeab920e9fb81fb185004e4e22f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ffeab920e9fb81fb185004e4e22f60">&#9670;&#160;</a></span>CCC_occupied</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_occupied</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_occupied(entry_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check occupancy of entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if Occupied, false if Vacant.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a3cf79b31383d758bc76e5fb20fd82ec1" name="a3cf79b31383d758bc76e5fb20fd82ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf79b31383d758bc76e5fb20fd82ec1">&#9670;&#160;</a></span>CCC_or_insert</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_or_insert</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">or_insert_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_or_insert(entry_pointer, or_insert_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert new element if the entry is Vacant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">or_insert_arguments</td><td>arguments depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an reference to the old element or new element if entry was Vacant.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a060c9cc6826bb39350be21750233ce71" name="a060c9cc6826bb39350be21750233ce71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060c9cc6826bb39350be21750233ce71">&#9670;&#160;</a></span>CCC_pop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_pop</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pop_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_pop(container_pointer, pop_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop an element from a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pop_arguments</td><td>any supplementary arguments a container may have for the pop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result of the pop operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a9ddf2fb67b4322c8cb48a7ecf09f3115" name="a9ddf2fb67b4322c8cb48a7ecf09f3115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddf2fb67b4322c8cb48a7ecf09f3115">&#9670;&#160;</a></span>CCC_pop_back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_pop_back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_pop_back(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop an element from the back of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result of the pop operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="adc6ea07e914d9bdd03424c39082299e5" name="adc6ea07e914d9bdd03424c39082299e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6ea07e914d9bdd03424c39082299e5">&#9670;&#160;</a></span>CCC_pop_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_pop_front</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_pop_front(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop an element from the front of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result of the pop operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ac5bdeefd70bfdffa2190329deb21ab8b" name="ac5bdeefd70bfdffa2190329deb21ab8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bdeefd70bfdffa2190329deb21ab8b">&#9670;&#160;</a></span>CCC_push</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_push</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">push_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_push(container_pointer, push_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push an element into a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">push_arguments</td><td>depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the pushed element.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a2f377a663decd0421b962bbc26da512f" name="a2f377a663decd0421b962bbc26da512f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f377a663decd0421b962bbc26da512f">&#9670;&#160;</a></span>CCC_push_back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_push_back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">push_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_push_back(container_pointer, push_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push an element to the back of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">push_arguments</td><td>depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the pushed element.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="af2bacf413e77ba2800653acc7bfe4ede" name="af2bacf413e77ba2800653acc7bfe4ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bacf413e77ba2800653acc7bfe4ede">&#9670;&#160;</a></span>CCC_push_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_push_front</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">push_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_push_front(container_pointer, push_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push an element to the front of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">push_arguments</td><td>depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the pushed element.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="af1e153edc4d813aeb8fcba9640c53d1a" name="af1e153edc4d813aeb8fcba9640c53d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e153edc4d813aeb8fcba9640c53d1a">&#9670;&#160;</a></span>CCC_range_begin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_range_begin</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_range_begin(range_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the beginning of the range iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range_pointer</td><td>a pointer to the type of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator representing the beginning. May be equal to end. </dd></dl>

</div>
</div>
<a id="a645dbec6c02190de14248d44ed642412" name="a645dbec6c02190de14248d44ed642412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645dbec6c02190de14248d44ed642412">&#9670;&#160;</a></span>CCC_range_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_range_end</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_range_end(range_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the end of the range iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range_pointer</td><td>a pointer to the type of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator representing the end. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not access the end. It is an exclusive end. </dd></dl>

</div>
</div>
<a id="ad055a9c9c00366a2fb4f4a5941a47adc" name="ad055a9c9c00366a2fb4f4a5941a47adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad055a9c9c00366a2fb4f4a5941a47adc">&#9670;&#160;</a></span>CCC_range_reverse_begin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_range_reverse_begin</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_reverse_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_range_reverse_begin(range_reverse_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the beginning of the reverse range iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range_reverse_pointer</td><td>a pointer to the type of reverse range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator representing the reverse beginning. May be equal to reverse end. </dd></dl>

</div>
</div>
<a id="a9cb020bf9603590a7175222e57871291" name="a9cb020bf9603590a7175222e57871291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb020bf9603590a7175222e57871291">&#9670;&#160;</a></span>CCC_range_reverse_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_range_reverse_end</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">range_reverse_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_range_reverse_end(range_reverse_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the end of the reverse range iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range_reverse_pointer</td><td>a pointer to the type of reverse range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator representing the reverse end. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not access the end. It is an exclusive reverse end. </dd></dl>

</div>
</div>
<a id="ac207035aea4cbe0c51d16589c2460db4" name="ac207035aea4cbe0c51d16589c2460db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac207035aea4cbe0c51d16589c2460db4">&#9670;&#160;</a></span>CCC_remove_entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_remove_entry</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_remove_entry(entry_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the element if the entry is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a4e80401338bc7980d63b75bf9c8cc108" name="a4e80401338bc7980d63b75bf9c8cc108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e80401338bc7980d63b75bf9c8cc108">&#9670;&#160;</a></span>CCC_remove_entry_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_remove_entry_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_remove_entry_wrap(entry_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the element if the entry is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a81a9141ace02d75b61a40e78fb070e08" name="a81a9141ace02d75b61a40e78fb070e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a9141ace02d75b61a40e78fb070e08">&#9670;&#160;</a></span>CCC_remove_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_remove_handle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">array_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_remove_handle(array_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the element if the handle is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a8fe3201d00f81e4ef8b5d060086561da" name="a8fe3201d00f81e4ef8b5d060086561da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe3201d00f81e4ef8b5d060086561da">&#9670;&#160;</a></span>CCC_remove_handle_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_remove_handle_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">array_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_remove_handle_wrap(array_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the element if the handle is Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="adf98612c9c130618b75ae727fb1fe150" name="adf98612c9c130618b75ae727fb1fe150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf98612c9c130618b75ae727fb1fe150">&#9670;&#160;</a></span>CCC_remove_key_value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_remove_key_value</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">remove_key_value_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_remove_key_value(container_pointer, remove_key_value_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an element and retain access to its value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove_key_value_arguments</td><td>arguments depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a2c4403f2a89ae5d3ec78b2b0cc5172b9" name="a2c4403f2a89ae5d3ec78b2b0cc5172b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4403f2a89ae5d3ec78b2b0cc5172b9">&#9670;&#160;</a></span>CCC_remove_key_value_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_remove_key_value_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">remove_key_value_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    CCC_private_remove_key_value_wrap(container_pointer,                       \</div>
<div class="line">                                      remove_key_value_arguments)</div>
</div><!-- fragment -->
<p>Remove an element and retain access to its value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove_key_value_arguments</td><td>arguments depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a716f00ed6954d4ba8ef0e122f7f20e65" name="a716f00ed6954d4ba8ef0e122f7f20e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716f00ed6954d4ba8ef0e122f7f20e65">&#9670;&#160;</a></span>CCC_reserve</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_reserve</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n_to_add, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">allocate_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_reserve(container_pointer, n_to_add, allocate_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve capacity for n_to_add new elements to be inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_to_add</td><td>the number of elements to add to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocate_pointer</td><td>the allocation function to use for resizing if needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the operation.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a6237dcd969f191f580d65d7fd63be4c5" name="a6237dcd969f191f580d65d7fd63be4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6237dcd969f191f580d65d7fd63be4c5">&#9670;&#160;</a></span>CCC_reverse_begin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_reverse_begin</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_reverse_begin(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the reversed start of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the user type stored at the reversed start.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a4e882e40fee89407d607872f31814381" name="a4e882e40fee89407d607872f31814381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e882e40fee89407d607872f31814381">&#9670;&#160;</a></span>CCC_reverse_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_reverse_end</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;    CCC_private_reverse_end(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the reverse_end sentinel of a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the reverse_end sentinel.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a1fab7d4aca5df5547f4474095f18b40a" name="a1fab7d4aca5df5547f4474095f18b40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fab7d4aca5df5547f4474095f18b40a">&#9670;&#160;</a></span>CCC_reverse_next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_reverse_next</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">void_iterator_pointer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_reverse_next(container_pointer, void_iterator_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the reverse_next element in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">void_iterator_pointer</td><td>the user type returned from the last iteration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the user type stored reverse_next.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="afd8b655cc1c871d1d86de0e2ab403e40" name="afd8b655cc1c871d1d86de0e2ab403e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8b655cc1c871d1d86de0e2ab403e40">&#9670;&#160;</a></span>CCC_splice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_splice</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">splice_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_splice(container_pointer, splice_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splice an element from one position to another in the same or a different container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">splice_arguments</td><td>are container specific. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the splice.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a7d7480fbdf342099370c59d90a1f386b" name="a7d7480fbdf342099370c59d90a1f386b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7480fbdf342099370c59d90a1f386b">&#9670;&#160;</a></span>CCC_splice_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_splice_range</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">splice_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_splice_range(container_pointer, splice_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splice a range of elements from one position to another in the same or a different container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">splice_arguments</td><td>are container specific. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the splice.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="aa7e463ec85c393e0bc31c026d3746e13" name="aa7e463ec85c393e0bc31c026d3746e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e463ec85c393e0bc31c026d3746e13">&#9670;&#160;</a></span>CCC_swap_entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_swap_entry</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">swap_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_swap_entry(container_pointer, swap_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element and obtain the old value if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">swap_arguments</td><td>arguments depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a3a5241223eb13697a7aae960f7fd5cbb" name="a3a5241223eb13697a7aae960f7fd5cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5241223eb13697a7aae960f7fd5cbb">&#9670;&#160;</a></span>CCC_swap_entry_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_swap_entry_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">swap_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_swap_entry_wrap(container_pointer, swap_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element and obtain the old value if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">swap_arguments</td><td>arguments depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a36fc6824695d97967f69e057494bcb25" name="a36fc6824695d97967f69e057494bcb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fc6824695d97967f69e057494bcb25">&#9670;&#160;</a></span>CCC_swap_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_swap_handle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">swap_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_swap_handle(container_pointer, swap_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element and obtain the old value if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">swap_arguments</td><td>arguments depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="af3c76ac87bc31b353faf0228b803be24" name="af3c76ac87bc31b353faf0228b803be24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c76ac87bc31b353faf0228b803be24">&#9670;&#160;</a></span>CCC_swap_handle_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_swap_handle_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">swap_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_swap_handle_wrap(container_pointer, swap_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element and obtain the old value if Occupied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">swap_arguments</td><td>arguments depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="af431d49e5a606da896a5fa211890ce75" name="af431d49e5a606da896a5fa211890ce75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af431d49e5a606da896a5fa211890ce75">&#9670;&#160;</a></span>CCC_try_insert</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_try_insert</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">try_insert_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_try_insert(container_pointer, try_insert_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element if the entry is Vacant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">try_insert_arguments</td><td>arguments depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ac2f4343b4d1deccfaf32ae3532299155" name="ac2f4343b4d1deccfaf32ae3532299155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f4343b4d1deccfaf32ae3532299155">&#9670;&#160;</a></span>CCC_try_insert_wrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_try_insert_wrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">try_insert_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_try_insert_wrap(container_pointer, try_insert_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element if the entry is Vacant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">try_insert_arguments</td><td>arguments depend on container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entry depending on container specific context.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="ab42510f7ed011f774d3549ef3c91d4a2" name="ab42510f7ed011f774d3549ef3c91d4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42510f7ed011f774d3549ef3c91d4a2">&#9670;&#160;</a></span>CCC_unwrap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_unwrap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_unwrap(entry_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unwrap user type in entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a valid reference if Occupied or NULL if vacant.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a9d71f5910f431f9336e6568dc3ef80b2" name="a9d71f5910f431f9336e6568dc3ef80b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d71f5910f431f9336e6568dc3ef80b2">&#9670;&#160;</a></span>CCC_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_update</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">update_arguments...&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    CCC_private_update(container_pointer, update_arguments)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the value of an element known to be in a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">update_arguments</td><td>depend on the container.</td></tr>
  </table>
  </dd>
</dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
<a id="a8e45c5f2d2e0a1221ce6310dfee7bce5" name="a8e45c5f2d2e0a1221ce6310dfee7bce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e45c5f2d2e0a1221ce6310dfee7bce5">&#9670;&#160;</a></span>CCC_validate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCC_validate</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container_pointer</td><td>)</td>
          <td>&#160;&#160;&#160;CCC_private_validate(container_pointer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the invariant statuses of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container_pointer</td><td>a pointer to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all invariants hold, false if not.</dd></dl>
<p>See container documentation for specific behavior. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_5d984c6d55e750c7f944f580303daf53.html">ccc</a></li><li class="navelem"><a class="el" href="traits_8h.html">traits.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
